-- ============================================================
-- Transforms an R2ML metamodel into RDM metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity and Derivation rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2RDM; -- Module Template
create OUT : RDM from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	firstCharToUpper
-- Converts first character of String to upper and return complete string.
-- CONTEXT:	String
-- OUT:		String
helper context String def: firstCharToUpper() : String =
	let firstChar : String = self.substring(1, 1) in
		firstChar.toUpper() + self.substring(2, self.size());

-- HELPER:	toBoolean
-- Converts String value to Boolean value
-- CONTEXT:	String
-- IN:		String
-- OUT:		Boolean
helper context String def: toBoolean() : Boolean =
	if self = 'true'
	then true
	else false
	endif;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ObjectClassificationAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ObjectClassificationAtom def: getTerm : R2ML!ObjectVariable = 
	self.term;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Disjunction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Disjunction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Conjuction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Conjuction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!UniversallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!UniversallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ExistentiallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ExistentiallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ReferencePropertyAtom def: getTerm : R2ML!ObjectVariable = 
	self.subject;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastAndAtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastAndAtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!EqualityAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!EqualityAtom def: getTerm : R2ML!ObjectVariable = 
	self.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!DatatypePredicateAtom def: getTerm : R2ML!DataVariable = 
	self.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AttributionAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!AttributionAtom def: getTerm : R2ML!Variable = 
	if self.dataValue.oclIsTypeOf(R2ML!DataVariable) then -- TODO: Check this
		self.dataValue
	else self.subject
	endif;

-- HELPER: getChildren
-- Returns all children for context Implication (for both, antecedent and consequent).
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getChildren : Sequence(R2ML!LogicalFormula) =
	self.getAntecedent->asSequence()->union(self.getConsequent->asSequence());
	
-- HELPER: getAntecedent
-- Returns antecedent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getAntecedent : Sequence(R2ML!LogicalFormula) 	=
	 if self.antecedent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.antecedent.isConjuctionFromIntersection then
			Sequence{self.antecedent}
		else self.antecedent.formulas
		endif
	 else Sequence{self.antecedent}
	 endif;
	
-- HELPER: getConsequent
-- Returns consequent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getConsequent : Sequence(R2ML!LogicalFormula) 	=
	if self.consequent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.consequent.isConjuctionFromIntersection then
			Sequence{self.consequent}
		else self.consequent.formulas
		endif
	 else Sequence{self.consequent}
	 endif; 
	
-- HELPER: getChildrenOfAllTopMostImplications
-- Returns all children elements (both, antecedents and consequents) for all topmost Implications (Rules).
-- OUT:		Sequence(R2ML!LogicalFormula)
helper def: getChildrenOfAllTopMostImplications() : Sequence(R2ML!LogicalFormula) =
	 let allImps : Sequence(R2ML!Implication) = thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten() in
  	 	allImps->collect(c | c.getChildren)->flatten();

-- HELPER: isConjuctionFromIntersection
-- Implements algorithm for checking is contextual Conjuction coming from RDM Intersection 
-- to Conjuction transformation. This is important, because Implication (RDM Rule)
-- can containts for antecedent or consequent Conjuction from multiple Atoms or from
-- Intersection.
-- CONTEXT:	R2ML!Conjuction
-- OUT:		Boolean
helper context R2ML!Conjuction def: isConjuctionFromIntersection : Boolean = 
		if R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self)
			and	self.formulas->size() = 2
			and self.formulas->asSequence()->first().getTerm = self.formulas->asSequence()->last().getTerm
			and ( self.formulas->select(c | c.oclIsTypeOf(R2ML!Disjunction))->collect(e | e.formulas)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!EqualityAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Implication))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Conjuction))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom)) 
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->size() = 0
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->size() = 0 )
			and self.formulas->collect(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->flatten()->size() > 0
		then true
		else false
		endif;

-- HELPER: getTopMostUniversallyQuantifiedFormulas
-- Returns all top-most UniversallyQuantifiedFormulas.
-- OUT:		 Sequence(R2ML!UniversallyQuantifiedFormula)
helper def: getTopMostUniversallyQuantifiedFormulas() : Sequence(R2ML!UniversallyQuantifiedFormula) =
	R2ML!AlethicIntegrityRule.allInstancesFrom('IN')->asSequence()->collect(c | c.constraint)->flatten();	
	
-- HELPER: isRefPropAtomForHasValue
-- Implements algorithm for checking is contextual ReferencePropertyAtom candidate
-- for RDM HasValueRestriction.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: isRefPropAtomForHasValue : Boolean =
	thisModule.getChildrenOfAllTopMostImplications()->excludes(self) and
	R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->excluding(thisModule.getTopMostUniversallyQuantifiedFormulas())->select(e | e.formula.oclIsTypeOf(R2ML!Implication))->collect(c | c.formula)->flatten()->collect(c | c.antecedent)->flatten()->excludes(self) and
	R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->select(e | e.formula.oclIsTypeOf(R2ML!Conjuction))->collect(c | c.formula.formulas->asSequence())->flatten()->excludes(self) and
	R2ML!AtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastAndAtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self);

----------------------------------------------------------------------------------
-- Helpers for transforming R2ML elements which are transformed from OCL metamodel
----------------------------------------------------------------------------------

-- HELPER:	getDatatypePredicateAtomsWithSubElems
-- Returns all Datatype predicate atoms with their subelems for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getDatatypePredicateAtomsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
	    self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()
	else if self.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
			self.getElementWithSubElems()
		 else OclUndefined
		 endif
	endif;

-- HELPER:	getReferencePropertyAtomsWithTermsWithSubElems
-- Returns all Reference property atoms with terms for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getReferencePropertyAtomsWithTermsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
		Sequence { self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | not c.subject.oclIsTypeOf(R2ML!ObjectVariable) or not c.object.oclIsTypeOf(R2ML!ObjectVariable))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence(),
  				   self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | c.subject.oclIsTypeOf(R2ML!ObjectVariable) and c.object.oclIsTypeOf(R2ML!ObjectVariable))->flatten()->asSequence() -- get basic ReferencePropertyAtom's
				 }
	else if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) or not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			self.getElementWithSubElems()->flatten()->asSequence()
		 else self
		 endif
	endif;

-- HELPER:	areAllObjectVariables
-- Returns all object variable in the R2ML ReferencePropertyAtom (for subject and object)
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: areAllObjectVariables() : Boolean =
	if self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
		if self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			true
		else false
		endif
	else false
	endif;

-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyAtom with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence{ if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
				self.subject.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif,
			  if not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
				self.object.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif
	}->flatten()->asSequence()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DatatypePredicateAtom with all sub elements
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!DatatypePredicateAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	self.dataArguments->select(c | not c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()->append(self);

-- HELPER:	getElementWithSubElems
-- Returns contextual AttributeFunctionTerm with all sub elements
-- CONTEXT:	R2ML!AttributeFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!AttributeFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyFunctionTerm with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DataOperationTerm with all sub elements
-- CONTEXT:	R2ML!DataOperationTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!DataOperationTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ObjectVariable with all sub elements (itself)
-- CONTEXT:	R2ML!ObjectVariable
-- OUT:		Sequence(OclAny)
helper context R2ML!ObjectVariable def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self };
	
-- HELPER:	getVariableName
-- Returns ReferencePropertyFunctionTerm contextArgument name (i.e. variable) with
-- referencePropertyRef name
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		String
helper context R2ML!ReferencePropertyFunctionTerm def: getVariableName() : String = 
		self.contextArgument.name + self.referencePropertyRef.name.firstCharToUpper();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Implication2Rule'
-- Create RDM Rule element from R2ML Implication element 
rule Implication2Rule {
	from i : R2ML!Implication (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten()->includes(i)
		)
	to o : RDM!Rule (
		hasAntecedent <- ant,
		hasConsequent <- con
		),
	ant : RDM!Antecedent (
		containsAtom <- if i.antecedent.oclIsTypeOf(R2ML!Conjuction) then
							if	i.antecedent.isConjuctionFromIntersection
							then
								i.antecedent
							else Sequence { i.antecedent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePredicateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.antecedent.getDatatypePredicateAtomsWithSubElems(),
											i.antecedent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.antecedent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.antecedent.getDatatypePredicateAtomsWithSubElems()
							 else if i.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.antecedent.getElementWithSubElems()
									   -- Check because of Intersection element with type of term
							 	  else if i.antecedent.oclIsTypeOf(R2ML!Disjunction) then
							 		    if i.antecedent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			   if not i.antecedent.getTerm.classRef.oclIsUndefined() then
											 -- Create Intersection with this type
											 thisModule.LogicalFormula2Intersection(i.antecedent)
										   else i.antecedent
										   endif
							 	        else i.antecedent
								        endif
								      else i.antecedent
								      endif
								 endif
							 endif
						endif
		),
	con : RDM!Consequent (
		containsAtom <- if i.consequent.oclIsTypeOf(R2ML!Conjuction) then
								if	i.consequent.isConjuctionFromIntersection
							then
								i.consequent
							else Sequence { i.consequent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePrediacateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.consequent.getDatatypePredicateAtomsWithSubElems(),
											i.consequent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.consequent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.consequent.getDatatypePredicateAtomsWithSubElems()
							 else if i.consequent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.consequent.getElementWithSubElems()
							 		   -- Check because of Intersection element with type of term
							 	  else if i.consequent.oclIsTypeOf(R2ML!Disjunction) then
							 		       if i.consequent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			       if not i.consequent.getTerm.classRef.oclIsUndefined() then
											      -- Create Intersection with this type
										      	thisModule.LogicalFormula2Intersection(i.consequent)
										       else i.consequent
										       endif
							 	          else i.consequent
								          endif
								       else i.consequent
								       endif
							     endif
							 endif
						endif
		)
}

-- Lazy rule 'LogicalFormula2Intersection'
-- Creates IntersectionClass RDM element from LogicalFormula R2ML element.
unique lazy rule LogicalFormula2Intersection {
	from i : R2ML!LogicalFormula
	to o :  RDM!Atom (
				name <- 'ClassAtom',
				hasPredicateSymbol <- intCla,
				terms <- thisModule.ObjectVariable2IndividualVariable(i.getTerm)
			),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { thisModule.Class2Class(i.getTerm.classRef),
										 i
									   }
			)	
}

-- IndividualPropertyAtom

-- Rule 'ReferencePropertyAtom2IndividualPropertyAtom'
-- Creates Atom RDM element (IndividualPropertyAtom) from ReferencePropertyAtom R2ML element.
rule ReferencePropertyAtom2IndividualPropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
		not i.isRefPropAtomForHasValue and i.areAllObjectVariables()
		)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty),
		terms <- Sequence { thisModule.ObjectVariable2IndividualVariable(i.object),
							thisModule.ObjectVariable2IndividualVariable(i.subject)}
		)
}

-- Rule 'ReferenceProperty2ObjectProperty'
-- Transformation from R2ML ReferenceProperty element to RDM ObjectProperty element.
unique lazy rule ReferenceProperty2ObjectProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!ObjectProperty (
			name <- i.name
		)
}

-- Rule 'ReferenceProperty2DatatypeProperty'
-- Transformation from R2ML ReferenceProperty element to RDM DatatypeProperty element.
unique lazy rule ReferenceProperty2DatatypeProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'ObjectVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML ObjectVariable.
unique lazy rule ObjectVariable2IndividualVariable {
	from i : R2ML!ObjectVariable
	to o : RDM!IndividualVariable (
			name <- i.name,
			classRef <- if not i.classRef.oclIsUndefined() then
							thisModule.Class2Class(i.classRef)
						else OclUndefined
						endif
		)		
}

-- Rule 'DataVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML DataVariable.
unique lazy rule DataVariable2IndividualVariable {
	from i : R2ML!DataVariable
	to o : RDM!IndividualVariable (
			name <- i.name
		)		
}

-- ClassAtom

-- Rule 'Conjuction2ClassAtom'
-- Create RDM ClassAtom with Intersection predicate symbol from R2ML Conjuction
rule Conjuction2ClassAtom {
	from i : R2ML!Conjuction (
		i.isConjuctionFromIntersection and
		-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
 	)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- intCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  		 i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
									   }
			)	
}

-- Rule 'DisjunctionAtom2Union'
-- Create RDM ClassAtom with UnionClass predicate symbol from R2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- children of top-most Implication.
rule DisjunctionAtom2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i) and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->includes(i) and 
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
		  )
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- uniCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'Disjunction2Union'
-- Create UnionClass predicateR2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- not children of top-most Implication.
rule Disjunction2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i)
		and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->excludes(i) or 
			-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					true
				else false
				endif
			else true
			endif
		  )
		)
	to uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'NegationAtom2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule NegationAtom2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- comCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.getTerm)
		),
		comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Negation2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule Negation2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Disjunction2EnumeratedClass'
-- Create EnumeratedClass from R2ML Disjunction.
rule DisjunctionFromIntersection2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->includes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->asSequence()->collect(c | c.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))->asSequence()
			)
}

-- Rule 'DisjunctionFromAtom2EnumeratedClass'
-- Create RDM ClassAtom with EnumeratedClass predicate symbol from R2ML Disjunction.
rule DisjunctionFromAtom2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to o : RDM!Atom	(
			name <- 'ClassAtom',
			hasPredicateSymbol <- enumClass,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->collect(e | e.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))
			)
}

-- Rule 'ObjectName2Individual'
-- Create RDM Individual from R2ML ObjectName.
rule ObjectName2Individual {
	from i : R2ML!ObjectName (
		R2ML!EqualityAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.terms)->flatten()->select(e | e.oclIsTypeOf(R2ML!ObjectName))->includes(i)
		)
	to o : RDM!Individual (
		name <- i.name
		)
}

-- Rule 'ObjectClassificationAtom2ClassAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element.
rule ObjectClassificationAtom2ClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = false
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- thisModule.Class2Class(i.type),
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element (that is negated).
rule ObjectClassificationAtomNegated2ComplementClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = true
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- cla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	),
	cla : RDM!Class (
			subClassOf <- Sequence { cs }
		),
	cs : RDM!ComplementClass (
			complementOf <- thisModule.Class2Class(i.type)
	)
}


-- Rule 'Class2Class'
-- Create RDM Class from R2ML Class element.
unique lazy rule Class2Class {
	from i : R2ML!Class
	to cla : RDM!Class (
				name <- i.name
			)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have ReferencePropertyAtoms as formulas.
rule ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have ReferencePropertyAtoms 
-- as formulas.
rule ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- svf,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().getTerm)
		),
	svf : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'UniversallyQuantifiedFormulaClass2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and ReferencePropertyAtom as antecedent.
rule UniversallyQuantifiedFormulaClass2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			then true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromClass <- if i.formula.consequent.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
									thisModule.Class2Class(i.formula.consequent)
							  else i.formula.consequent
							  endif,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.antecedent.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2HasValue'
-- Creates HasValueRestriction RDM element from R2ML ReferencePropertyAtom, if
-- ReferencePropertyAtom is for this type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2HasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2ClassAtomHasValue'
-- Creates RDM Atom with HasValueRestriction as predicate symbol from 
-- R2ML ReferencePropertyAtom, if ReferencePropertyAtom is for this 
-- type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2ClassAtomHasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- hvr,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.subject)
		),
	hvr : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ObjectVariable2Individual'
-- Creates Individual RDM element from R2ML ObjectVariable (lazy rule).
unique lazy rule ObjectVariable2Individual {
	from i : R2ML!ObjectVariable
	to o : RDM!Individual (
			name <- i.name
		)		
}

-- Rule 'AtLeastQuantifiedFormula2MinCardinalityRestriction'
-- Creates MinCardinalityRestriction RDM element from R2ML AtLeastQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormula2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
	   card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
			)
}

-- Rule 'AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <-thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaClass2MaxCardinalityRestriction'
-- Creates MaxCardinalityRestriction RDM element from R2ML AtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaClass2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MaxCardinalityRestriction (
		maxCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction'
-- Creates CardinalityRestriction RDM element from R2ML AtLeastAndAtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality = i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!CardinalityRestriction (
		cardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction'
-- Creates MinCardinalityRestriction and MaxCardinalityRestriction RDM elements
-- from R2ML AtLeastAndAtMostQuantifiedFormula, which have different max and
-- min cardinality.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  	  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					      endif
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- DataRange Atom

-- Rule 'DataClassificationAtom2DataRangeAtomOneOf'
-- Create RDM Atom from R2ML DataClassificationAtom element, which is
-- children of top most Implication.
rule DataClassificationAtom2DataRangeAtomOneOf {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
	)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- thisModule.DataVariable2IndividualVariable(i.term)
		),
		dtr : RDM!DataRange(
			datatype <- i.type
			)
}

-- Rule 'DataClassificationAtom2DataRange'
-- Create RDM DataRange from R2ML DataClassificationAtom element, which is not
-- children of top most Implication.
rule DataClassificationAtom2DataRange {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
	)
	to dtr : RDM!DataRange(
		datatype <- i.type
		)
}

-- Rule 'Disjunction2DataRangeAtom'
-- Create RDM Atom from R2ML Disjunction element, which is
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRangeAtom {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- Sequence{thisModule.DataVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)}
		),
		dtr : RDM!DataRange(
			oneOf <- i.formulas
			)
}

-- Rule 'Disjunction2DataRange'
-- Create RDM DataRange from R2ML Disjunction element, which is not
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRange {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!DataRange (
		oneOf <- i.formulas
		)
}

-- Rule 'Datatype2PrimitiveType'
-- Create RDM PrimitiveType from R2ML Datatype element.
rule Datatype2PrimitiveType {
	from i : R2ML!Datatype (
		i.oclIsTypeOf(R2ML!Datatype)
		)
	to o : RDM!PrimitiveType (
		name <- i.name
		)
}

-- Rule 'PlainLiteral2PlainLiteral'
-- Create RDM PlainLiteral from R2ML PlainLiteral element, if it is not 
-- value of top most AttributionAtom and not dataArgument of DatatypePredicateAtom.
rule PlainLiteral2PlainLiteral {
	from i : R2ML!PlainLiteral (
		i.oclIsTypeOf(R2ML!PlainLiteral) and 
		thisModule.getChildrenOfAllTopMostImplications()->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->collect(c | c.value)->flatten()->excludes(i) and
		R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments)->flatten()->excludes(i)
		)
	to o : RDM!PlainLiteral (
	    language <- i.languageTag,
		lexicalForm <- i.lexicalValue
		)
}

-- Rule 'TypedLiteral2TypedLiteral'
-- Create RDM TypedLiteral from R2ML TypedLiteral element.
rule TypedLiteral2TypedLiteral {
	from i : R2ML!TypedLiteral (
		i.oclIsTypeOf(R2ML!TypedLiteral) 
		and R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments )->flatten()->excludes(i)
		)
	to o : RDM!TypedLiteral (
			theType <- i.type.name,
			lexicalForm <- i.lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2PlainLiteral'
-- Create RDM PlainLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument PlainLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2PlainLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!PlainLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!PlainLiteral (
		language <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().languageTag,
		lexicalForm <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2TypedLiteral'
-- Create RDM TypedLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument TypedLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2TypedLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!TypedLiteral (
		theType <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().type.name,
		lexicalForm <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates RDM Atom with AllValuesFromRestriction as predicate symbol from 
-- R2ML UniversallyQuantifiedFormula element, which have Implication as its 
-- formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2DataRangeAtomAllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- alr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	alr : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- smr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	smr : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'Attribute2DatatypeProperty'
-- Lazy rule which creates RDM DatatypeProperty from R2ML Attribute.
unique lazy rule Attribute2DatatypeProperty {
	from i : R2ML!Attribute
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'TypedLiteral2DataValue'
-- Lazy rule which creates RDM DataValue from R2ML TypedLiteral.
unique lazy rule TypedLiteral2DataValue {
	from i : R2ML!TypedLiteral
	to o : RDM!DataValue(
			value <- i.lexicalValue,
			type <- i.type
		)
}

-- Rule 'AttributeAtomData2DataValuedPropertyAtom'
-- Creates RDM Atom from R2ML AttributionAtom, which is children of
-- top most Implication.
rule AttributeAtomData2DataValuedPropertyAtom {
	from i : R2ML!AttributionAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'DataValuedPropertyAtom',
		hasPredicateSymbol <- thisModule.Attribute2DatatypeProperty(i.attribute),
		terms <- if i.dataValue.oclIsTypeOf(R2ML!TypedLiteral) then
					Sequence { thisModule.TypedLiteral2DataValue(i.dataValue),
							   thisModule.ObjectVariable2IndividualVariable(i.subject)
							 }
				 else
					Sequence { thisModule.DataVariable2DataVariable(i.dataValue),
				 			   thisModule.ObjectVariable2IndividualVariable(i.subject)
				 			 }
				 endif
		)
}

-- Rule 'AttributionAtomData2HasValueRestriction'
-- Creates RDM HasValueRestriction from R2ML AttributionAtom, which is not children of
-- top most Implications.
rule AttributionAtomData2HasValueRestriction {
	from i : R2ML!AttributionAtom (
		not thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o :  RDM!HasValueRestriction (
			hasLiteralValue <- i.dataValue,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.attribute)
		)
}

-- Rule 'DataVariable2DataVariable'
-- Lazy rule which creates RDM DataVariable from R2ML DataVariable.
unique lazy rule DataVariable2DataVariable {
	from i : R2ML!DataVariable
	to o : RDM!DataVariable (
			name <- i.name
		)		
}

-- Rule 'EqualityAtom2SameIndividualAtom'
-- Creates RDM Atom from R2ML EqualityAtom, which is not
-- children (formulas) of Disjunction.
rule EqualityAtom2SameIndividualAtom {
	from i : R2ML!EqualityAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i)
		)
	to o : RDM!Atom (
		name <- 'SameIndividualAtom',
		hasPredicateSymbol <- same,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		same : RDM!SameAs
}

-- Rule 'InequalityAtom2DifferentIndividualAtom'
-- Creates RDM Atom from R2ML InequalityAtom.
rule InequalityAtom2DifferentIndividualAtom {
	from i : R2ML!InequalityAtom (
		i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : RDM!Atom (
		name <- 'DifferentIndividualAtom',
		hasPredicateSymbol <- different,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		different : RDM!DifferentFrom
}

-- Rule 'DatatypePredicateAtom2BulitinAtom'
-- Creates RDM Atom from R2ML DatatypePredicateAtom, which is not
-- formula of some Disjunction.
rule DatatypePredicateAtom2BulitinAtom {
	from i : R2ML!DatatypePredicateAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i) and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0 and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataOperationTerm))->size() = 0
		)
	to o : RDM!Atom (
		name <- 'BulitinAtom',
		hasPredicateSymbol <- thisModule.DatatypePredicate2BuiltIn(i.predicate),
		terms <-  Sequence { i.dataArguments->select(e | e.oclIsKindOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),
							 i.dataArguments->select(e | e.oclIsKindOf(R2ML!TypedLiteral))->collect(c | thisModule.TypedLiteral2DataValue(c))							
						    }
		)
}

-- Rule 'DatatypePredicate2BuiltIn'
-- Lazy rule which creates RDM BuiltIn from R2ML DatatypePredicate.
unique lazy rule DatatypePredicate2BuiltIn {
	from i : R2ML!DatatypePredicate 
	to o : RDM!BuiltIn (
		buildInID <- i.name
		)
}